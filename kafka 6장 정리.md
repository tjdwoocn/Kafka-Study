# 컨슈머의 내부 동작 원리와 구현

- 컨슈머의 주요 역할은 카프카에 저장된 메시지를 가져오는 것

<br/>

***

## 6.1 컨슈머 오프셋 관리
- 컨슈머의 동작 중 가장 핵심 = 오프셋 관리
- 컨슈머가 메시지를 어디까지 가져왔는지를 표시하는 것은 매우 중요
	- 코드 배포로 인해 컨슈머가 일시적으로 동작을 멈추고 재시작 하는 경우
	- 컨슈머가 구동 중인 서버에서 문제가 발생해 새로운 컨슈머가 기존 컨슈머의 역할을 대신하는 경우
- 오프셋: 메시지의 위치를 나타내는 것
- 오프셋 정보는 카프카에서 가장 안전한 저장소인 토픽에 저장
- __consumer_offsets 토픽에 각 컨슈머 그룹별로 오프셋 위치 정보를 기록

- 컨슈머 그룹은 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합해 기록
- 여기서 저장되는 오프셋값은, 컨슈머가 마지막까지 읽은 위치가 아닌, 컨슈머가 다음으로 읽어야 할 위치를 뜻함
- __consumer_offsets 토픽의 파티션과 replication factor의 수는 각각 50과 3으로 셋팅되어 있음 (브로커의 설정 파일인 server.properties에서 관리자가 변경 가능)(이정도면 보통 충분)

<br/>

***

## 6.2 그룹 코디네이터
- 컨슈머들은 하나의 컨슈머 그룹의 구성원이며 하나의 공동체로 동작함. 언제든지 떠날 수 있고 언제든 새로운 컨슈머가 합류할 수 있음
- 그룹의 변화에 따라 컨슈머별로 작업을 균등하게 분배해야하며 이 동작을 컨슈머 리밸런싱이라고 부름
- 안정적인 컨슈머 그룹 관리를 위해 '그룹 코디네이터'가 존재
- 그룹 코디네이터의 목적: 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹 하는 것
- 그룹 코디네이터는 각 컨슈머 그룹별로 존재하며 카프카 클러스터 내의 브로커 중 하나에 위치
	1. 컨슈머 그룹이 브로커에 최초 연결 요청을 보내면
	2. 브로커 중 하나에 그룹 코디네이터가 생성
	3. 생성된 그룹 코디네이터는 컨슈머 그룹의 컨슈머 변경과 구독하는 토픽 파티션 변경 등에 대한 감지를 시작
	4. 토픽의 파티션과 그룹의 멤버 변경이 일어나면 변경된 내용을 컨슈머들에게 알려주기도 합니다. 

![컨슈머 그룹 등록 과정, 동작 과정](경로)

	- 컨슈머 그룹이 안정적으로 메시지를 읽어갈 수 있기 위해 유지되어야 하는 과정들

- 컨슈머가 그룹 코디네이터에게 join 또는 leave 요청을 보냄으로써 그룹 코디네이터에게 그룹의 변화를 알림
- 하지만 장애로 leave 요청을 보내지 못하고 종료되는 경우엔?
	- 컨슈머들의 변경을 감지하기 위해 그룹 코디네이터와 컨슈머들은 하트비트를 주고 받음(컨슈머가 죽었는지 살았는지 확인)
	- heartbeat.interval.ms: 그룹 코디네이터와 하트비트 인터벌 시간
	- session.timeout.ms: 컨슈머가 정해진 시간 안에 하트비트를 받지 못한다면 문제 발생이라고 판단, 해당 컨슈머 제거 및 리밸런싱 진행
	- max.poll.interbal.ms: 컨슈머의 poll() 호출 후 최대 5분간(임의의) 새로운 poll() 호출이 없다면 컨슈머가 문제가 있는 것으로 판단하여 리밸런싱 진행

- 컨슈머 리밸런싱 동작은 경우에 따라 높은 비용이 발생하므로 리밸런싱이 자주 발생하지 않도록 주의
- 옵션 값들을 컨슈머의 다운을 너무 빠르게 감지하도록 설정해둔다면, 일시적인 컨슈머의 타임아웃이나 일시적인 TCP 패킷 손실로 인해 원하지 않은 리밸런싱이 자주 발생할 수 있음
- 반대의 경우, 파티션의 메시지를 제때 읽지 못하는 현상이 발생
***
<br/>

## 6.3 스태틱 멤버십
- 하드웨어 점검이나 소프트웨어 업데이트 등의 이유로 각 컨슈머가 재시작될 때마다 리밸런싱이 일어나는데, 이때마다 컨슈머들은 일시 중지되므로 매우 번거로우며 효율적이지 못함
- 대용량 메시지를 처리하는 컨슈머 그룹의 경우 리밸런싱 동작에 걸리는 시간이 오래걸림.
- 불필요한 리밸런싱을 방어하기 위해 아파치 카프카 2.3 버전부터 스태틱 멤버십 이라는 개념이 도입됨
- 스태틱 멤버십: 그룹 내의 컨슈머가 재시작 등으로 그룹에서 나갔다 다시 합류할때 리밸런싱이 일어나지 않게 함.(인식을 위해 엔티티 ID 부여)
	- 스태틱 멤버십 기능이 적용된 컨슈머는 그룹에서 떠날 때 그룹 코디네이터에 알리지 않아 불필요한 리밸런싱도 발생하지 않음

 > [실습] 스태틱 멤버십 동작 p188 ~ p200 중반까지
 > - 실습코드 및 실습과정과 결과 추가

<br/>

***

## 6.4 컨슈머 파티션 할당 전략 p200
- 컨슈머 파티셔너의 경우 토픽의 어느 파티션으로부터 레코드를 읽어올지를 결정함
- 컨슈머 그룹의 리더 컨슈머가 정해진 파티션 할당 전략에 따라 각 컨슈머와 대상 토픽의 파티션을 매칭함
- 파티션 할당 전략:
	- RangeAssignor(레인지 전략): 기본값, 토픽별로 할당 전략 사용, 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할때 유용
	- RoundRobinAssignor(라운드 로빈 전략): 균등 분배
	- StickyAssignor(스티키 전략): 컨슈머가 컨슘하고 있는 파티션을 계속 유지 가능
	- CooperativeStickyAssignor(협력적 스티키 전략): 전체 일시 정지가 아닌 연속적인 재조정 방식

### 6.4.1 레인지 파티션 할당 전략
- 각 토픽별로 할당 전략 사용
- 불균형하게 할당 되기도 하는 레인지 파티션 할당 전략은, 동일한 메시지 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 떄 유용


### 6.4.2 라운드 로빈 
- 가장 간단한 할당 방식
- 하나하나씩 파티션과 컨슈머를 할당
- 레인지 파티션 전략에 비해 좀 더 균등하게 매핑가능

### 6.4.3 스티키
- 컨슈머 그룹의 리밸런싱 동작으로 인해 파티션이 재할당될경우,
위의 전략들은 기존에 매핑됐던 파티션과 동일한 컨슈머가 다시 매핑되리라는 보장이 없음.
	- 재할당 작업이 발생하더라도 기존의 매핑을 최대한 유지하려는 전략

- 두가지 목적
	- 가능한 한 균형 잡힌 파티션 할당
	- 재할당시 되도록 기존의 할당된 파티션 정보 보장
	- 첫번째 목적의 우선순위가 더 높음
- 문제 발생시, 문제와는 상관없이 잘 연결되어 있는 파티션과 컨슈머 조합은 매핑을 유지한채 조합이 깨진 파티션만 새로운 파티션에 순차적으로 할당됨

### 6.4.4 협력적 스티키
- 결과적으론 스티키 전략과 동일
- 한가지 차이점은, 컨슈머 그룹 내부의 리밸런싱 동작이 한층 더 고도화 됐다는 점

> * 리밸런싱 동작에서 모든 파티션을 항상 취소하는 이유
>	- 컨슈머들의 파티션 소유권 변경 이슈
>	- 그룹 내에서 여러 파티션들에 대해 소유권 변경 작업이 동시에 이뤄져야 하므로 로직을 단순하게 구현하기 위함

- 그러나 리밸런싱에서 모든 파티션 할당을 취소하는 동작은 리소스르 많이 사용하는 컨슈머 그룹에서는 큰 문제임 -> 컨슈머들의 다운타임

![리밸런싱 전체 동작 과정 ](경로)
1. 감지
2. 중지 (이때부터 다운타임 시작)
3. 재시작 (다운타임 종료)

![ 협력적 스티키 리밸런싱 동작 과정](경로)
1. 감지
2. 첫 번쨰 리밸런싱
3. 두 번째 리밸런싱

<br/>

***

## 6.5 정확히 한 번 컨슈머 동작
- 프로듀서가 '정확히 한 번 전송'을 하기 위해선 트랜잭션 코디네이터가 있어야 하고, 이 기능이 정상 작동하면 해당 레코드의 트랜잭션 성공을 표시하는 특수한 메세지가 추가됨
	- 컨슈머는 이 특수한 메시지를 표시한 레코드만 읽는다면, 정확히 한 번 읽을 수 있음
- 일반 컨슈머 코드에서 ISOLATION_LEVEL_CONFIG라는 설정을 추가
- 기본값이 read_uncommitted로 되어 있는데 read_committed로 옵션을 변경하면 트랜잭션이 완료된 메시지만 읽게 됨
- 트랜잭션 메시지의 경우 사용자들에게 보여주는 목적이 아닌 트랜잭션의 성공 여부 확인만을 위한 목적으로 활용됨
- 트랜잭션 컨슈머라고 무조건 정확히 한 번만 가져오는것은 아님 (코디네이터와 통신하는 부분이 없어 해당 기능 보장되지 않음)
- 또한 컨슈머가 정확히 한 번 메시지를 가져왓더라도, 해당 메시지가 다른 애플리케이션에 저장되는 과정에서 중복 저장 되기도 하는데, 이 부분에 대한 확인을 할 수 없어, 정확히 한 번 저장에 관한것도 보장할 수 없음
	- 이를 방지하기 위해선, 컨슘-메시지 처리-프로듀싱 동작이 하나의 트랜잭션으로 처리되어야 함
	- 일부 컨슈머 애플리케이션에선 정확히 한 번을 지원하는 경우도 있음

<br/>

***

## 정리
- 카프카로 메시지를 전송하는 것 도 중요하지만, 어떻게 카프카로부터 안전하게 메시지를 가져오는지도 매우 중요함.
- 메시지를 가져올 때는
	- 지연이 발생하지 않아야 함
	- 손실되는 메시지가 없어야 함
	- 중복도 발생하지 않아야 함

### 추가 참고 링크
- 카프카 컨슈머 강의: <https://www.youtube.com/watch?v=5FEE5wVi8uY> (데브원영, Tacademy)
